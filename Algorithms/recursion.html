<html>
    <head>
        <meta charset="UTF-8">
        <title>출력결과</title>
    </head>
    <body>
        <script>
            // 1. 재귀함수
            // function solution(n){
            //     function DFS(L){
            //         if(L==0) return; // 종료조건 -> 콜스택에 누적된 L값들이 최근 값부터 순차적으로 호출됨 (*stack: LIFO)
            //         else{
            //             DFS(L-1); // -> 인자를 1씩 줄여가며 게속 함수를 호출한다 => 콜스택에 누적됨 
            //             console.log(L);   
            //         }
            //     }
            //     DFS(n);
            // }
            // solution(3);
            // 2. 이진수 출력
            // function solution(n) {
            //   let answer="";
            //   function DFS(n) {
            //     if(n === 0) return;
            //     else {
            //       DFS(parseInt(n/2));              
            //       answer += (n%2);
            //     }
            //   }
            //   DFS(n);
            //   return answer;
            // }
            // console.log(solution(11));
            // 3. 이진트리 순회
            // function solution(v) {
            //     let answer;
            //     function DFS(v) {
            //         if(v>7) { 
            //             return; // 멈추는 조건
            //         } else {
            //             console.log(v) // 전위순회는 여기서 출력
            //             DFS(v*2); // 왼쪽 노드
            //             // 중위 순회는 여기서 출력
            //             DFS(v*2+1); // 오른쪽 노드
            //             // 후위 순회는 여기서 출력

            //         }
            //     }
            //     DFS(v)
            //     return answer;
            // }
            // console.log(solution(1))
            // 4. 부분집합 구하기
            // function solution(n) {
            //     let answer = [];
            //     let ch = Array.from({length:n+1}, ()=>0);
            //     function DFS(v) {
            //         if(v===n+1) { 
            //             let tmp = "";
            //             for (let i = 1; i <= n; i++ ) {
            //                 if (ch[n] === 1) tmp += i + " ";
            //             }
            //             if(tmp.length > 0) answer.push(tmp.trim());
            //         } else {
            //             ch[v]=1;
            //             DFS(v+1);
            //             ch[v]=0;
            //             DFS(v+1);
            //         }
            //     }
            //     DFS(1)
            //     return answer;
            // }
            // console.log(solution(3))
            // **정답
            // function solution(n){
            //     let answer=[];
            //     let ch=Array.from({length:n+1}, ()=>0);
            //     function DFS(L){
            //         if(L===n+1){
            //             let tmp="";
            //             for(let i=1; i<=n; i++){
            //                 if(ch[i]===1) tmp+=(i+" ");
            //             }
            //             if(tmp.length>0) answer.push(tmp.trim());
            //         }
            //         else{
            //             ch[L]=1;
            //             DFS(L+1);
            //             ch[L]=0;
            //             DFS(L+1);
            //         }
            //     }
            //     DFS(1);
            //     return answer;
            // }

            // console.log(solution(3));
            // 5. 합이 같은 부분집합
            // function solution(arr) {
            //     let answer = "NO", flag=0;
            //     let total = arr.reduce((a,b) => a+b, 0);
            //     let n = arr.length;
            //     function DFS(L, sum) { // L 로 주어진 숫자를 부분집합의 원소로 쓸지 안쓸지 결정
            //         if(flag) return; // 종료시점
            //         if (L===n) {
            //             if((total-sum)===sum) {
            //                 answer="YES"; 
            //                 flag = 1;
            //             }
            //         } else {
            //             DFS(L+1, sum+arr[L]);
            //             DFS(L+1, sum)
            //         }
            //     }
            //     DFS(0,0);
            //     return answer;
            // }
            // let arr = [1, 3, 5, 6, 7, 10];
            // console.log(solution(arr));

            // 6. 바둑이승차 (DFS) === 결국은 부분집합 문제와 유사
            // function solution (c, arr) {
            //     let answer = Number.MIN_SAFE_INTEGER;
            //     let n = arr.length;
            //     function DFS(L, sum) {
            //         if (L===n) {
            //             if (sum > c) return;
            //             answer = Math.max(answer, sum);
            //         } else {
            //             DFS(L+1, sum+arr[L]); // 태운 경우
            //             DFS(L+1, sum); // 태우지 않은 경우
            //         }
            //     }
            //     DFS(0,0);
            //     return answer;
            // }

            // let arr = [81, 58, 42, 33, 61];
            // console.log(solution(259,arr));

            // 7. 최대점수 (시간제한)
            // 재귀 호출 로직: D(문제번호, 획득점수, 소요한 시간)
            // function solution(m, ps, pt) {
            //     let answer=Number.MIN_SAFE_INTEGER; // 최대점수를 리턴한다
            //     let n = ps.length;
            //     function DFS(L, sum, time) {
            //         if (time>m) return;
            //         if (L===n) {
            //             answer=Math.max(answer, sum);
            //         } else {
            //             DFS(L+1, sum+ps[L], time+pt[L]); // 문제를 풀기로 한 경우
            //             DFS(L+1, sum, time); // 문제를 안푸는 경우
            //         }
            //     }
            //     DFS(0,0,0);
            //     return answer;
            // }
            // let ps = [10, 25, 15, 6, 7];
            // let pt = [5, 12, 8, 3, 4];
            // console.log(solution(20, ps, pt))

            // 8. 중복순열 구하기
            // 왜 재귀함수를 쓰는지? : 본질적으로는 n중 for문과 같으나, n이 바뀔때마다 자동으로 코드를 짤수는 없음..
            // 재귀함수를 이용하면 좀 더 유연한 코드 대응이 가능
            // function solution(n, m) {
            //     let answer = [];
            //     let tmp = Array.from({length:m}, () => 0);
            //     function DFS(L) {
            //         if (L===m) { // m중 for문 도는것과 같은 원리
            //             answer.push(tmp.slice()); // 깊은복사
            //         } else {
            //             for (let i=1; i <=n; i++) {
            //                 tmp[L] = i;
            //                 DFS(L+1);
            //             }
            //         }
            //     }
            //     DFS(0)
            //     return answer;
            // }
            // console.log(solution(3,2));

            // 9. 동전교환
            // function solution(m,arr) {
            //     let answer = Number.MAX_SAFE_INTEGER;
            //     let n = arr.length;
            //     function DFS (L, sum) {
            //         if (sum > m) return;
            //         if (L >= answer) return;
            //         if (sum === m) {
            //             console.log(L, sum);
            //             answer=Math.min(answer, L);
            //         } else {
            //             for (let i = 0; i < n; i++) {
            //                 DFS(L+1, sum+arr[i]);
            //             }
            //         }
            //     }
            //     DFS(0,0);
            //     return answer;
            // }
            // const arr = [1,2,5];
            // console.log(solution(15, arr));

            // 10. 순열 구하기
            // 중복을 피하기 위해서 check 배열 생성 필요 -> tmp 배열에 해당 원소가 들어가있으면 1 아니면 0
            // function solution (m, arr) { //m=순열 아이템의 갯수
            //     let answer = [];
            //     n = arr.length;
            //     let ch = Array.from({length: n}, () => 0);
            //     let tmp = Array.from({length:m}, () => 0);
            //     function DFS(L) {
            //         if (L===m) {
            //             answer.push(tmp.slice());
            //         } else {
            //             for(let i=0; i<n; i++) {
            //                 if (ch[i]===0) {
            //                     ch[i] = 1;
            //                     tmp[L] = arr[i];
            //                     DFS(L+1); // 다음 배열 아이템으로 넘어가고
            //                     ch[i]=0; // 1로 체크되어있는 check 배열값을 원래대로 되롤림
            //                 }
            //             }
            //         }
            //     }
            //     DFS(0);
            //     return answer;
            // }
            // let arr = [3, 6, 9, 5];
            // console.log(solution(2, arr));

            // 11. 팩토리얼
            // function solution (n) {
            //     let answer;
            //     function DFS(n) {
            //         if (n===1) {
            //             return 1;
            //         } else {
            //             return n * DFS(n-1);
            //         }
            //     }
            //     answer = DFS(n);
            //     return answer;
            // }
            // console.log(solution(5));

            // 12. 조합 (메모이제이션)
            // 1) simple solution
            // function solution (n, r) {
            //     let answer;
            //     function DFS(n, r) {
            //         if (n===r || r===0) {
            //             return 1;
            //         } else {
            //             return DFS(n-1, r-1) + DFS(n-1, r);
            //         }            
            //     }
            //     answer = DFS(n, r);
            //     return answer;
            // }
            // 2) memoization solution: 2차원 배열에 값을 저장한 후 재계산하지 않도록 
            // function solution (n, r) {
            //     let answer;
            //     let dy = Array.from(Array(35), () =>Array(35).fill(0)); // 조합 계산 값을 저장하는 2차원 배열
            //     function DFS(n, r) {
            //         if (dy[n][r]) return dy[n][r]; // 이미 배열에 저장되어있다면 재계산하지 않고 그 값을 불러옴
            //         if (n===r || r===0) return 1;
            //         else return dy[n][r] = DFS(n-1, r-1) + DFS(n-1, r);
            //     }
            //     answer = DFS(n, r);
            //     return answer;
            // }            

            // console.log(solution(33, 19))
            
            //13. 수열 추측하기 
            // function solution(n, f) {
            //     let answer, flag;
            //     let dy = Array.from(Array(11), () => Array(11).fill(0));
            //     let ch = Array.from({length: n+1}, ()=>0); 
            //     let p =  Array.from ({length: n}, ()=>0); // 순열값 저장
            //     let b = Array.from({length: n}, ()=>0); // 조합값 저장
            //     function combi(n, r) {
            //         if (dy[n][r]>0) return dy[n][r];
            //         if(n===r || r===0) return 1;
            //         else return dy[n][r]=combi(n-1, r-1)+combi(n-1, r); 
            //     }
            //     function DFS(L, sum) { // sum == final 값
            //         if(flag) return;
            //         if(L===n && sum === f) {
            //             answer = p.slice();
            //         } else {
            //             for(let i=1; i<=n; i++) {
            //                 if (ch[i] === 0) {
            //                     ch[i] = 1; // 순열 계산되었음으로 체크?
            //                     p[L] = i;
            //                     DFS(L+1, sum+(b[L]*p[L]));
            //                     ch[i] = 0;
            //                 }
            //             }
            //         }
            //     }

            //     // 조합값을 구해서 b에 저장해둔다
            //     for (let i=0; i<n; i++) {
            //         b[i] = combi(n-1, i);                    
            //     }
            //     DFS(0,0);
            //     return answer;
            // }
            // console.log(solution(4, 16))

            // 14. 조합구하기
            // function solution(n,m) {
            //     let answer = [];
            //     let tmp = Array.from({length:m}, ()=>0);
            //     function DFS (L, s) {
            //         if (L === m) {
                        
            //         } else {
            //             for (let i=s; i <=n; i++) {
            //                 tmp[L] = i;
            //                 DFS(L+1, i+1)
            //             }
            //         }
            //     }
            //     DFS(0,1);
            //     return answer;
            // }
            // 15. 수들의 조합
            function solution(n, k, arr, m){         
                let answer=0;
                function DFS(L, s, sum){
                    if(L===k){
                        if(sum%m===0) answer++; // 숫자의 합이 6의 배수인경우는 카운트++
                    } else{
                        for(let i=s; i<n; i++){
                            DFS(L+1, i+1, sum+arr[i]); // 뽑은 숫자의 합을 누적해준다
                        }
                    }
                }

                DFS(0, 0, 0);
                return answer;
            }

            let arr=[2, 4, 5, 8, 12];
            console.log(solution(5, 3, arr, 6));            
        </script>
    </body>
</html>
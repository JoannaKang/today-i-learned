<html>
    <head>
        <meta charset="UTF-8">
        <title>출력결과</title>
    </head>
    <body>
        <script>
            // 1. 경로탐색(DFS-인접행렬:노드개수 적을 때) 
            // function solution(n, arr){  
            // // 현재 탐색중인 노드를 기록해두는 check 배열이 필요
            // // 가장 깊은 노드까지 탐색한 경우 그 전 노드로 돌아와야함, 그리고 answer++ -> 돌아오면서 check 풀어주기
            // // 다음 노드로 탐색 가능한 노드까지 돌아오기 -> 다시 가장 깊은 노드까지 탐색
            //   let answer = 0;
            //   // 그래프 2차원 배열로 변환: 초기값은 모두 0으로 세팅
            //   let graph = Array.from(Array(n+1), ()=>Array(n+1).fill(0));
            //   // 현재 탐색중인 노드를 기록하는 check배열
            //   let ch = Array.from({length: n+1}, ()=>0);
            //   let path = [];
            //   for (let [a, b] of arr) {
            //     graph[a][b]=1; // 인접행렬 생성
            //   }
            //   function DFS(v) { // 방문 가능한 모든 정점을 완전탐색
            //     if(v===n) {
            //       answer++;
            //       console.log(path);
            //     } else {
            //       for (let i=1; i<=n; i++) {
            //         if (graph[v][i] === 1 && ch[i]===0) { //방문하려는 정점에 갈 수 있고(연결되어 있고), 아직 방문하지 않았을 때
            //           ch[i] = 1; // 방문했다고 표시
            //           path.push(i);
            //           DFS(i); // 다음노드 탐색
            //           ch[i] = 0; // 가장 깊은 노드까지 탐색한 경우, 다시 이전 노드로 돌아감
            //           path.pop();
            //         }
            //       }
            //     }
            //   }
            //   path.push(1);
            //   ch[1] = 1; // 1번 정점은 무조건 탐색한 것으로 표시
            //   DFS(1) // 1번 정점부터 탐색 시작
            //   return answer;
            // }

            // let arr=[[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]];
            // console.log(solution(5, arr));

            // 2. 경로탐색: DFS-인접리스트: 노드개수가 많을 때
            // function solution(n, arr){  
            //   let answer = 0;
            //   let graph = Array.from(Array(n+1), ()=>Array());
            //   let ch = Array.from({length:n+1}, ()=>0);
            //   // 인접리스트 생성 
            //   for (let [a, b] of arr) {
            //     graph[a].push(b);
            //   }
            //   function DFS(v) {
            //     if (v===n) answer++;
            //     else {
            //       for (let i = 0; i <= graph[v].length; i++) {
            //         if(ch[graph[v][i]] === 0) { // 이동하려는 정점이 체크되어있는지를 확인해야함
            //           ch[graph[v][i]] = 1;
            //           DFS(graph[v][i]);
            //           ch[graph[v][i]] = 0;
            //         }
            //       }
            //     }
            //   }
            //   ch[1] = 1;
            //   DFS(1);
            //   return answer;
            // }

            // let arr=[[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]];
            // console.log(solution(5, arr));

            // 4. 미로탐색
            // function solution(board){  
            //   let answer = 0;
            //   let dx =  [-1, 0, 1, 0];
            //   let dy = [0, 1, 0, -1];
            //   function DFS(x, y) {
            //     if(x ===6 && y === 6) answer++;
            //     else  {
            //       for (let k = 0; k<4; k++) {
            //         let nx = x + dx[k];
            //         let ny = y + dy[k];
            //         if (nx >=0 && nx <= 6 && ny>=0 && board[nx][ny]===0) {
            //           board[nx][ny] = 1; // 이동하는 지점
            //           DFS(nx, ny);
            //           board[nx][ny] = 0; // 뒤로 돌아가는 지점
            //         }
            //       }
            //     }
            //   }
            //   //출발지점 설정
            //   board[0][0] = 1;
            //   DFS(0, 0);
            //   return answer;
            // }

            // let arr=[[0, 0, 0, 0, 0, 0, 0], 
            //         [0, 1, 1, 1, 1, 1, 0],
            //         [0, 0, 0, 1, 0, 0, 0],
            //         [1, 1, 0, 1, 0, 1, 1],
            //         [1, 1, 0, 0, 0, 0, 1],
            //         [1, 1, 0, 1, 1, 0, 0],
            //         [1, 0, 0, 0, 0, 0, 0]];

            // console.log(solution(arr));

            // 6. 이진트리 넓이 우선 탐색
            // function solution() {
            //   let answer = "";
            //   let queue = [];
            //   queue.push(1);
            //   while(queue.length) {
            //     let v = queue.shift();
            //     answer += v +" ";
            //     for (let nv of [v*2, v*2+1]) {
            //       if (nv>7) continue;
            //       queue.push(nv);
            //     }
            //   }
            //   return answer;
            // }
            // console.log(solution());

            // 7. 송아지 찾기
            // function solution(s, e){  
            //   let answer = 0;
            //   let ch = Array.from({length: 10001}, ()=>0);
            //   let dis = Array.from ({length: 10001}, ()=>0);
            //   let queue = [];
            //   dis[s] = 1;
            //   queue.push(s); // 현수의 출발 위치
            //   dis[s] = 0;
            //   while (queue.length) {
            //     let x = queue.shift();
            //     for (let nx of [x-1, x+1, x+5]) {
            //       if (nx === e) return dis[x]+1; // 점프해온 숫자에 +1 한 값이 정답
            //       if (nx>0 && nx <= 10000 && ch[nx] === 0) { // 방문하지 않은 지점일 경우
            //         ch[nx] = 1;
            //         queue.push(nx);
            //         dis[nx] = dis[x] + 1;
            //       }
            //     }
            //   }
            //   return answer;
            // }

            // console.log(solution(5, 14));

          // 8. 섬나라 아일랜드 (DFS)
          // function solution(board){  
          //   let answer=0;
          //       let n=board.length;
          //       let dx=[-1, -1, 0, 1, 1, 1, 0, -1]; // 시계방향 순회
          //       let dy=[0, 1, 1, 1, 0, -1, -1, -1]; // 반시계방향 순회
          //       function DFS(x, y){
          //         board[x][y]=0;
          //         for(let k=0; k<8; k++){
          //             let nx=x+dx[k];
          //             let ny=y+dy[k];
          //             // 보드 경계 밖으로 나가지 않도록 조건을 걸어줌
          //             if(nx>=0 && nx<n && ny>=0 && ny<n && board[nx][ny]===1){
          //               console.log(nx, ny)
          //               DFS(nx, ny);
          //             }
          //         } 
          //       }

          //       for(let i=0; i<n; i++){
          //           for(let j=0; j<n; j++){
          //               if(board[i][j]===1){
          //                   board[i][j]=0;
          //                   answer++;
          //                   DFS(i, j);
          //                   console.log("DFS end")
          //               }
          //           }
          //       }
          //       return answer;
          //   }

          //   let arr=[[1, 1, 0, 0, 0, 1, 0], 
          //           [0, 1, 1, 0, 1, 1, 0],
          //           [0, 1, 0, 0, 0, 0, 0],
          //           [0, 0, 0, 1, 0, 1, 1],
          //           [1, 1, 0, 1, 1, 0, 0],
          //           [1, 0, 0, 0, 1, 0, 0],
          //           [1, 0, 1, 0, 1, 0, 0]];

          //   console.log(solution(arr));

          // 9. 섬나라 아일랜드 (BFS)
          function solution(board){  
                let answer=0;
                let n=board.length;
                let dx=[-1, -1, 0, 1, 1, 1, 0, -1];
                let dy=[0, 1, 1, 1, 0, -1, -1, -1];
                let queue=[];
                for(let i=0; i<n; i++){
                    for(let j=0; j<n; j++){
                        if(board[i][j]===1){
                            board[i][j]=0;
                            queue.push([i, j]);
                            answer++;
                            while(queue.length){
                                let x=queue.shift();
                                for(let k=0; k<8; k++){
                                    let nx=x[0]+dx[k];
                                    let ny=x[1]+dy[k];
                                    if(nx>=0 && nx<n && ny>=0 && ny<n && board[nx][ny]===1){
                                        board[nx][ny]=0;
                                        queue.push([nx, ny]);
                                    }
                                }
                            }
                            
                        }
                    }
                }
                return answer;
            }

            let arr=[[1, 1, 0, 0, 0, 1, 0], 
                    [0, 1, 1, 0, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 1, 1],
                    [1, 1, 0, 1, 1, 0, 0],
                    [1, 0, 0, 0, 1, 0, 0],
                    [1, 0, 1, 0, 1, 0, 0]];

            console.log(solution(arr));
        
        </script>
    </body>
</html>